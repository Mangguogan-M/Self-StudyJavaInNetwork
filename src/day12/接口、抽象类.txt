抽象类
抽象方法

抽象方法就是指不能被具体实现的方法，也就是没有方法体，并且使用abstract关键字修饰；

语法格式：
    访问修饰符   abstract  void  show();

抽象类

抽象类就是指使用abstract关键字修饰的类，抽象类不能被实例化对象。

注意事项

1.抽象类中可以有成员变量、成员方法以及构造方法；
2.抽象类中可以有抽象方法也可以没有；
3.拥有抽象方法的类必须是抽象类，因此通常情况下认为拥有抽象方法并且有abstract
    关键字修饰的类才认为是真正的抽象类；

实际意义

抽象类的意义不再与实例化对象而在于被继承，若一个类继承自抽象类则必须重写抽象方法，否则该类也得变成抽象类。
因此，抽象类对子类具有强制性和规范性，叫做模板设计模式。

    在开发中推荐使用父类引用指向子类的对象形式，因为父类引用直接调用的方法一定是
父类拥有的方法，当需要更换指向子类对象的时候，只需要将new后面的改方式类型更改一下就可以了，其他的代码无需改动，因此提高了代码的可维护性和可扩展性。

    该方式的缺点在于：父类引用不能直接调用子类独有的方法，若调用则需要强制类型转换。




抽象总结

抽象关键字  abstract    ，当abstract修饰类，就是抽象类，抽象类不能被实例化，
当 abstract 修饰方法抽象方法没有方法体，继承抽象类，必然要重写抽象方法。

接口
基本概述

接口就是一种比抽象类还抽象的类，该类型不能实例化对象。

定义类的关键字是class   而定义接口的关键字是interface

继承类的关键字是extends，而实现接口的关键字是implements

当多个类型之间具有相同的行为能力的时候，java中就可以通过接口来进行类型之间的联系。
通过接口可以解决java中单继承所带来的一些类型无法共享的问题。

接口定义了某一些规范，并且需要去遵守
接口不关心类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供的某些方法。

语法格式

修饰符  interface  接口名称 [extends 父接口1,父接口2,......] {
    零个到多个常量的定义.........
    零个到多个抽象方法的定义......
    零个到多个默认方法定义.......（jdk1.8新特性）
    零个到多个静态方法的定义.......（jdk1.8新特性）

}

注意事项

    1.接口可以实现多继承，也就是说一个接口可以同时继承多个父接口。
    2.实现接口的类如果不能实现所有接口中待重写的方法，则必须设置为抽象类。
    3.一个类可以继承自一个父类，同时实现多个接口。
    4.接口中的所有成员变量都必须有public static final共同修饰，也就是常量。
    5.接口中所有成员方法必须有public abstract共同修饰，也就是抽象方法。

    金属          黄金          货币

类和接口之间关系

类和类之间采用继承的关系        使用extends关键         支持单继承
类与接口之间采用实现的关系       使用implements关键字     支持多实现
接口与接口之间采用继承的关系  使用extends关键字            通常认为支持单继承

抽象类和接口的主要区别(笔试题)

1.定义抽象类的关键是class，而定义接口的关键字是interface。
2.继承抽象类关键字extends，而实现接口关键字 implements
3.继承抽象类支持单继承，而实现接口支持多实现。
4.抽象类有构造方法，但是接口没有
5.接口中的所有的成员变量都必须是常量，而抽象类中可以是变量。
6.接口中的所有成员方法都必须是抽象方法，而抽象类中可以是普通方法
7.接口中增加方法一定影响子类，而抽象类中可以不影响。

接口中的常量为什么必须使用public static final修饰

public 作用修饰符公开的，也就是说接口的实现类可以使用这个变量。

static 修饰就是表示类的，随着类的加载而存在的
    如果不是static的话，就表示属于对象的，只有创建对象才能有它，而接口是不能创建对象的，所以接口的常量定义必须为static。

final 修饰就是保存接口定义的常量不能被实现类去修改，如果没有final的话，由子类随意修改，接口建立常量将没有意义了。

内部类(了解)
基本概述

当一个类的定义放在另一个类的实体时，则该类叫做内部类，该类所在的类叫做外部类。
在一个类体中可以出现的内容：成员变量、成员方法、构造方法、构造块、静态语句块、静态变量、方法、内部类。

嵌套类：
    内部类(成员内部类、局部内部类、匿名内部类)  
    静态嵌套类

语法格式

class 外部类类名{
    class 内部类类名{
        内部类的类体;
    }

}

成员内部类

成员内部类定义在另一个类或接口中的内部类


注意事项：
    1.必须先创建外部类对象才能创建成员内部类对象
    2.不能含有静态变量、静态代码块、静态方法(除了静态常量)
    3.外部类可通过成员内部类的对象调用内部类私有成员
    4.成员内部类是一个独立的类，编译成独立的.class文件

作用：
    成员内部类既可以访问外部类信息，又可以访问父类信息，从而使多继承的解决方案变得完整。

局部内部类

局部内部类是定义在方法或代码块里的内部类


注意事项：
    1.不能含有静态变量、静态代码块、静态方法

    2.只能在定义该类的方法或代码块中使用，必须在使用前定义

    3.防伪码它所有方法的局部变量的时候，局部变量必须是有效的常量。

    4.是一个独立的类，编译成独立的.class文件    

    5.只能使用abstract、final修饰

    6.定义静态块或方法时候，只能访问外部类的静态成员。

匿名内部类

匿名内部类是直接使用接口或父类实例化对象时创建没有名字的内部类。

语法格式：
    接口/父类类型  引用名 = new 接口/父类类型(){
        进行方法的重写;
    };


注意事项：
    1.必须且仅能继承一个父类或实现一个接口
    2.没有class关键字，没有类名
    3.是特殊的局部内部类
    4.仅能使用一次
    5.不能定义构造方法
    6.匿名类不能是抽象类


优点以及作用：
    匿名内部类可以使我们的代码更加紧凑，简洁、封装性比较好

    匿名内部类可以灵活的创建

    匿名内部类使用多继承的解决方案比较完整

静态嵌套类

静态嵌套类定义在另一个类、接口，使用static关键字修饰的嵌套类


注意事项：
    1.不需要通过生成外部类对象来生成静态嵌套类对象
    2.只能直接访问外部类的静态成员
    3.外部类可通过静态嵌套类的对象调用内部类的成员
    4.可以定义静态成员变量或静态成员方法。

静态嵌套类和非静态嵌套类的区别

    名称              内部类(非静态嵌套类)         静态嵌套类

    定义位置上       成员位置、方法、代码块         只能在外部类的成员位置
    组成              实例成员、静态常量、构造方法      实例成员、静态成员、静态代码块、构造方法
    对象创建            必须先有外部类对象               不依赖于外部类实例，可以直接实例化
    访问外部类       可以直接访问外部类所有成员       只能直接访问外部类的静态成员

